import numpy as np
import cv2
import heapq
import matplotlib.pyplot as plt

# Constants
robot_clearance_buffer = 5  # Clearance in mm
map_width_pixels, map_height_pixels = 1200, 500  # Map dimensions in mm
OBSTACLE_COLOR = (0, 0, 255)  # Obstacles color in BGR (red)
CLEARANCE_COLOR = (0, 0, 0)   # Clearance color in BGR (black)
FREE_SPACE_COLOR = (255, 255, 255)  # Free space color in BGR (white)
EXPLORED_COLOR = (0, 255, 0)  # Explored nodes color in BGR (green)
PATH_COLOR = (255, 0, 0)  # Path color in BGR (blue)

# Actions with their costs
actions = {
    'UP': ('UP', (0, -1), 1),
    'DOWN': ('DOWN', (0, 1), 1),
    'LEFT': ('LEFT', (-1, 0), 1.0),
    'RIGHT': ('RIGHT', (1, 0), 1.0),
    'UP_LEFT': ('UP_LEFT', (-1, -1), 1.4),
    'UP_RIGHT': ('UP_RIGHT', (1, -1), 1.4),
    'DOWN_LEFT': ('DOWN_LEFT', (-1, 1), 1.4),
    'DOWN_RIGHT': ('DOWN_RIGHT', (1, 1), 1.4),
}

# Placeholder for explored nodes visualization
explored_nodes = []

# Initialize the map image
map_img = np.full((map_height_pixels, map_width_pixels, 3), FREE_SPACE_COLOR, dtype=np.uint8)

# Function to draw obstacles with clearance zone
def draw_obstacle_with_clearance_zone(img, obstacle, clearance):
    # Draw the clearance area in black
    for rect in obstacle:
        cv2.rectangle(img, (rect[0][0] - clearance, rect[0][1] - clearance),
                      (rect[1][0] + clearance, rect[1][1] + clearance), CLEARANCE_COLOR, -1)
    # Draw the obstacle in red within the black clearance area
    for rect in obstacle:
        cv2.rectangle(img, rect[0], rect[1], OBSTACLE_COLOR, -1)

# Define and draw the obstacles with clearance
c_shape_obstacle = [
    [(900, 50), (1100, 125)],  # Left vertical part of 'C'
    [(1020, 50), (1100, 450)],  # Top horizontal part of 'C'
    [(900, 375), (1100, 450)]  # Bottom horizontal part of 'C'
]

additional_rectangles = [
    [(100, 0), (175, 400)],  # First rectangle
    [(275, 100), (350, 500)]  # Second rectangle
]

draw_obstacle_with_clearance_zone(map_img, c_shape_obstacle + additional_rectangles, robot_clearance_buffer)

# Function to draw the hexagon adjusted for clearance
def draw_hexagon_with_clearance_zone(img, center, side):
    clearance_points = calculate_hexagon_vertices(center, side + robot_clearance_buffer)
    cv2.fillPoly(img, [clearance_points], CLEARANCE_COLOR)
    inner_hexagon_points = calculate_hexagon_vertices(center, side)
    cv2.fillPoly(img, [inner_hexagon_points], OBSTACLE_COLOR)

# Helper function to calculate hexagon vertices
def calculate_hexagon_vertices(center, side):
    start_angle = np.pi / 6  # Starting with flat side on top
    return np.array([
        (int(center[0] + np.cos(start_angle + np.pi / 3 * i) * side),
         int(center[1] + np.sin(start_angle + np.pi / 3 * i) * side))
        for i in range(6)
    ], np.int32).reshape((-1, 1, 2))

hexagon_center = (650, 250)
hexagon_side = 150
draw_hexagon_with_clearance_zone(map_img, hexagon_center, hexagon_side)

# Function to check if a position is within map boundaries
def is_position_within_map(x, y):
    return 0 <= x < map_width_pixels and 0 <= y < map_height_pixels

# Function to check if a position is in the obstacle space
def is_in_obstacle_space(position):
    x, y = position
    
    # Check for 'C' shaped obstacle with clearance
    if ((900 - CLEARANCE <= x <= 1100 + CLEARANCE and 375 - CLEARANCE <= y <= 450 + CLEARANCE) or
        (1020 - CLEARANCE <= x <= 1100 + CLEARANCE and 50 - CLEARANCE <= y <= 450 + CLEARANCE) or
        (900 - CLEARANCE <= x <= 1100 + CLEARANCE and 50 - CLEARANCE <= y <= 125 + CLEARANCE)):
        return True

    # Check for first rectangle with clearance
    if 100 - CLEARANCE <= x <= 175 + CLEARANCE and 0 - CLEARANCE <= y <= 400 + CLEARANCE:
        return True

    # Check for second rectangle with clearance
    if 275 - CLEARANCE <= x <= 350 + CLEARANCE and 100 - CLEARANCE <= y <= 500 + CLEARANCE:
        return True

    # Check for hexagon with clearance
    hex_center = (650, 250)
    hex_radius = hexagon_side + CLEARANCE  # Adding clearance to the radius
    hex_points = hexagon_points(hex_center, hex_radius)
    if cv2.pointPolygonTest(hex_points.reshape((-1, 1, 2)), (x, y), False) >= 0:
        return True

    return False
 
# Dijkstra's algorithm
def dijkstra(start, goal):
    global explored_nodes
    open_list = []
    heapq.heappush(open_list, (0, start))
    came_from = {}
    cost_so_far = {start: 0}

    while open_list:
        current_cost, current_node = heapq.heappop(open_list)

        if current_node == goal:
            break

        for action, (dx, dy), action_cost in actions.values():
            next_node = (current_node[0] + dx, current_node[1] + dy)
            if is_position_within_map(*next_node) and not is_position_in_obstacle(next_node):
                new_cost = cost_so_far[current_node] + action_cost
                if next_node not in cost_so_far or new_cost < cost_so_far[next_node]:
                    cost_so_far[next_node] = new_cost
                    priority = new_cost
                    heapq.heappush(open_list, (priority, next_node))
                    came_from[next_node] = current_node
                    explored_nodes.append(next_node)

    return came_from, cost_so_far
